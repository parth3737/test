*&---------------------------------------------------------------------*
*&  Include           ZRP_OPEN_ORDER_REPORT_FORM
*&---------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Form  FETCH_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM fetch_data .
  DATA: lv_parvw   TYPE parvw,
        ls_knvp    TYPE ty_knvp,
        lr_kunnr   TYPE RANGE OF kna1-kunnr,
        ls_kunnr   LIKE LINE OF lr_kunnr,
        lflg_matnr TYPE abap_bool.

  CLEAR: gt_vbak,gt_vbap,gt_vbup,gt_final,gt_mara.

  IF s_matnr IS NOT INITIAL OR s_matkl IS NOT INITIAL.
    lflg_matnr = abap_true.
    SELECT matnr matkl FROM mara INTO TABLE gt_mara
                       WHERE matnr IN  s_matnr
                        AND matkl IN s_matkl.
    IF sy-subrc IS INITIAL.
      SELECT matnr vbeln posnr FROM vapma
                              INTO TABLE gt_vapma
                              FOR ALL ENTRIES IN gt_mara
                              WHERE matnr = gt_mara-matnr
                                AND vkorg IN s_vkorg
                                AND spart IN s_spart
                                AND auart IN s_auart
                                AND vbeln IN s_vbeln
                                AND ernam IN s_ernam.

      IF sy-subrc IS INITIAL.
        SELECT vbeln erdat ernam auart vkorg vtweg spart vdatu kunnr FROM vbak
                                   INTO TABLE gt_vbak
                                   FOR ALL ENTRIES IN gt_vapma
                                  WHERE vbeln = gt_vapma-vbeln
                                    AND erdat IN s_erdat
                                    AND ernam IN s_ernam
                                    AND vbtyp = 'C'.
      ENDIF.
    ENDIF.

  ELSEIF s_payer IS NOT INITIAL OR p_parvw IS NOT INITIAL.

    CALL FUNCTION 'CONVERSION_EXIT_PARVW_INPUT'
      EXPORTING
        input  = p_parvw
      IMPORTING
        output = lv_parvw.


    SELECT kunnr parvw kunn2 lifnr
         FROM knvp INTO TABLE gt_knvp
         WHERE kunn2 IN s_payer AND parvw = lv_parvw AND vkorg IN s_vkorg.

    IF sy-subrc IS INITIAL.

      SELECT vbeln erdat ernam auart vkorg vtweg spart vdatu kunnr FROM vbak
                                     INTO TABLE gt_vbak
                                     FOR ALL ENTRIES IN gt_knvp
                                    WHERE vbeln IN s_vbeln
                                      AND erdat IN s_erdat
                                      AND ernam IN s_ernam
                                      AND vbtyp = 'C'
                                      AND auart IN s_auart
                                      AND spart IN s_spart
                                      AND kunnr = gt_knvp-kunnr.


    ENDIF.
  ENDIF.

  IF lflg_matnr IS NOT INITIAL AND ( s_payer IS NOT INITIAL OR p_parvw IS NOT INITIAL ).

    CALL FUNCTION 'CONVERSION_EXIT_PARVW_INPUT'
      EXPORTING
        input  = p_parvw
      IMPORTING
        output = lv_parvw.


    SELECT kunnr parvw kunn2 lifnr
         FROM knvp INTO TABLE gt_knvp
         WHERE kunn2 IN s_payer AND parvw = lv_parvw AND vkorg IN s_vkorg.

    IF sy-subrc IS INITIAL.
      LOOP AT gt_knvp INTO ls_knvp.
        ls_kunnr-sign =  'I'.
        ls_kunnr-option = 'EQ'.
        ls_kunnr-low = ls_knvp-kunnr.
        APPEND ls_kunnr TO lr_kunnr.
      ENDLOOP.

      DELETE gt_vbak WHERE kunnr NOT IN lr_kunnr.

    ENDIF.
  ENDIF.


  IF gt_vbak IS INITIAL.

    SELECT vbeln erdat ernam auart vkorg vtweg spart vdatu kunnr FROM vbak
                                  INTO TABLE gt_vbak
                                 WHERE vbeln IN s_vbeln
                                   AND erdat IN s_erdat
                                   AND ernam IN s_ernam
                                   AND vbtyp = 'C'
                                   AND auart IN s_auart
                                   AND vkorg IN s_vkorg
                                   AND spart IN s_spart.

  ENDIF.

  IF gt_vapma IS NOT INITIAL.
    SELECT vbeln posnr matnr netwr kwmeng FROM vbap
                                        INTO TABLE gt_vbap
                                        FOR ALL ENTRIES IN gt_vapma
                                        WHERE vbeln = gt_vapma-vbeln
                                          AND posnr = gt_vapma-posnr.
  ELSEIF gt_vbak IS NOT INITIAL.
    SELECT vbeln posnr matnr netwr kwmeng FROM vbap
                                          INTO TABLE gt_vbap
                                          FOR ALL ENTRIES IN gt_vbak
                                          WHERE vbeln = gt_vbak-vbeln.
  ENDIF.
  IF sy-subrc IS INITIAL.

    SELECT vbeln posnr lfgsa wbsta fksta gbsta FROM vbup
                                         INTO TABLE gt_vbup
                                         FOR ALL ENTRIES IN gt_vbap
                                         WHERE vbeln = gt_vbap-vbeln
                                           AND posnr = gt_vbap-posnr.

    SELECT vbelv posnv vbeln posnn vbtyp_n rfmng_flo erdat FROM vbfa
                                   INTO TABLE gt_vbfaj
                                   FOR ALL ENTRIES IN gt_vbap
                                   WHERE vbelv = gt_vbap-vbeln
                                     AND posnv = gt_vbap-posnr
                                     AND vbtyp_n = 'J'.


    SELECT vbelv posnv vbeln posnn vbtyp_n rfmng_flo erdat FROM vbfa
                             INTO TABLE gt_vbfam
                             FOR ALL ENTRIES IN gt_vbfaj
                             WHERE vbelv = gt_vbfaj-vbeln
                               AND posnv = gt_vbfaj-posnn
                               AND vbtyp_n = 'M'.

    SELECT vbelv posnv vbeln posnn vbtyp_n  rfmng_flo erdat FROM vbfa
                               INTO TABLE gt_vbfak
                               FOR ALL ENTRIES IN gt_vbfaj
                               WHERE vbelv = gt_vbfaj-vbeln
                                 AND posnv = gt_vbfaj-posnn
                                 AND vbtyp_n = 'R'.

    SELECT vbelv posnv vbeln posnn vbtyp_n rfmng_flo erdat FROM vbfa
                                   INTO TABLE gt_vbfa5
                                   FOR ALL ENTRIES IN gt_vbap
                                   WHERE vbelv = gt_vbap-vbeln
                                     AND posnv = gt_vbap-posnr
                                     AND vbtyp_n = '5'.

    IF gt_vbfaj IS NOT INITIAL.
      SELECT vbeln lfdat FROM likp INTO TABLE gt_likp
                         FOR ALL ENTRIES IN gt_vbfaj
                         WHERE vbeln = gt_vbfaj-vbeln.

      SELECT vbeln posnr lfgsa wbsta fksta gbsta FROM vbup
                                         APPENDING TABLE gt_vbup
                                         FOR ALL ENTRIES IN gt_vbfaj
                                         WHERE vbeln = gt_vbfaj-vbeln
                                           AND posnr = gt_vbfaj-posnn.

    ENDIF.

    IF gt_vbfam IS NOT INITIAL.
      SELECT vbeln fksto FROM vbrk INTO TABLE gt_vbrk_vbeln
                   FOR ALL ENTRIES IN gt_vbfam
                   WHERE vbeln = gt_vbfam-vbeln.

    ENDIF.

    IF gt_vbfa5 IS NOT INITIAL.
      SELECT vbeln fksto FROM vbrk APPENDING TABLE gt_vbrk_vbeln
                   FOR ALL ENTRIES IN gt_vbfa5
                   WHERE vbeln = gt_vbfa5-vbeln.

    ENDIF.
    IF gt_mara IS INITIAL.
      SELECT matnr matkl FROM mara
                         INTO TABLE gt_mara
                         FOR ALL ENTRIES IN gt_vbap
                         WHERE matnr = gt_vbap-matnr.

    ENDIF.

    IF gt_mara IS NOT INITIAL.
      SELECT * FROM makt
                         INTO TABLE gt_makt
                         FOR ALL ENTRIES IN gt_mara
                         WHERE matnr = gt_mara-matnr
                           AND spras = sy-langu.
    ENDIF.

    IF gt_knvp IS INITIAL.
      SELECT kunnr parvw kunn2 lifnr FROM knvp
                               INTO TABLE gt_knvp
                               FOR ALL ENTRIES IN gt_vbak
                               WHERE kunnr = gt_vbak-kunnr.

      SELECT kunnr parvw kunn2 lifnr FROM knvp
                               APPENDING TABLE gt_knvp
                               FOR ALL ENTRIES IN gt_knvp
                               WHERE kunnr = gt_knvp-kunn2.

    ENDIF.

    IF gt_knvp IS NOT INITIAL.
      SELECT kunnr name1 FROM kna1
        INTO TABLE gt_kna1
        FOR ALL ENTRIES IN gt_knvp
          WHERE kunnr = gt_knvp-kunnr.

      SELECT kunnr name1 FROM kna1
        APPENDING TABLE gt_kna1
          FOR ALL ENTRIES IN gt_vbak
          WHERE kunnr = gt_vbak-kunnr.

    ENDIF.
  ENDIF.
ENDFORM.                    " FETCH_DATA
*&---------------------------------------------------------------------*
*&      Form  MERGE_DATA
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM merge_data .
  DATA: ls_final        TYPE zopen_ord_output,
        ls_vbak         TYPE ty_vbak,
        ls_makt         TYPE makt,
        ls_kna1         TYPE ty_kna1,
        lv_jmeng        TYPE rfmng,
        lv_meng         TYPE rfmng,
        lv_kmeng        TYPE rfmng,
        lv_wmengj       TYPE rfmng,
        lv_wmengk       TYPE rfmng,
        lv_wmengm       TYPE rfmng,
        ls_mara         TYPE ty_mara,
        lflg_no_dlv     TYPE abap_bool,
        ls_vbfak        TYPE ty_vbfa,
        ls_vbfam        TYPE ty_vbfa,
        ls_vbfaj        TYPE ty_vbfa,
        ls_likp         TYPE ty_likp,
        ls_vbup         TYPE ty_vbup,
        ls_vbupj        TYPE ty_vbup,
        ls_knvp         TYPE ty_knvp,
        lv_lfgsa        TYPE char1,
        lflg_so_sts_chk TYPE char1,
        ls_vbap         TYPE ty_vbap.

  SORT gt_vbak BY vbeln.
  SORT gt_knvp BY kunnr parvw.
  DELETE ADJACENT DUPLICATES FROM gt_knvp COMPARING ALL FIELDS.
  SORT gt_kna1 BY kunnr.
  DELETE ADJACENT DUPLICATES FROM gt_kna1 COMPARING ALL FIELDS.
  SORT gt_makt BY matnr.
  SORT gt_mara BY matnr.
  SORT gt_vbfaj BY vbelv posnv vbtyp_n.
  SORT gt_vbfak BY vbelv posnv vbtyp_n.
  SORT gt_vbfam BY vbelv posnv vbtyp_n.
  SORT gt_likp BY vbeln.
  SORT gt_vbrk_vbeln BY vbeln fksto.
  SORT gt_vbup BY vbeln posnr.
  SORT gt_vbap BY vbeln posnr.

  LOOP AT gt_vbap INTO ls_vbap.

    CLEAR: ls_vbak, ls_makt, ls_mara, ls_vbfaj, ls_likp, ls_vbup,
           ls_knvp, ls_kna1, lv_wmengk, ls_vbfak, ls_vbfam, lv_lfgsa,
           ls_final, lv_wmengm, lv_wmengj,lflg_no_dlv,ls_vbupj,lflg_so_sts_chk.


    MOVE-CORRESPONDING ls_vbap TO ls_final.

    READ TABLE gt_vbup INTO ls_vbup WITH KEY vbeln = ls_final-vbeln
                                             posnr = ls_final-posnr
                                             BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      MOVE-CORRESPONDING ls_vbup TO ls_final.
      lv_lfgsa = ls_vbup-lfgsa.
    ENDIF.
    IF ls_vbup-lfgsa = 'A'.
      ls_final-lfgsa = 'Not yet delivered'.
    ELSEIF ls_vbup-lfgsa = 'B'.
      ls_final-lfgsa = 'Partially delivered'.
    ELSEIF ls_vbup-lfgsa = 'C'.
      ls_final-lfgsa = 'Completely delivered'.
    ENDIF.

    READ TABLE gt_vbak INTO ls_vbak WITH KEY vbeln = ls_vbap-vbeln
                                    BINARY SEARCH.
    IF sy-subrc IS NOT INITIAL.
      CONTINUE.
    ENDIF.
    MOVE-CORRESPONDING ls_vbak TO ls_final.
*    READ TABLE gt_knvp INTO ls_knvp WITH KEY kunnr = ls_vbak-kunnr
*                                             parvw = 'AG'
*                                    BINARY SEARCH.
*    IF sy-subrc IS INITIAL.
*      ls_final-slifn = ls_knvp-lifnr.
*    ENDIF.

    READ TABLE gt_kna1 INTO ls_kna1 WITH KEY kunnr = ls_vbak-kunnr BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-name = ls_kna1-name1.
    ENDIF.

    READ TABLE gt_knvp INTO ls_knvp WITH KEY kunnr = ls_vbak-kunnr
                                             parvw = 'RG'
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-kunn2 = ls_knvp-kunn2.
      READ TABLE gt_kna1 INTO ls_kna1 WITH KEY kunnr = ls_knvp-kunn2 BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        ls_final-name1 = ls_kna1-name1.
      ENDIF.
    ENDIF.

    READ TABLE gt_makt INTO ls_makt WITH KEY matnr = ls_final-matnr
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-maktx = ls_makt-maktx.
    ENDIF.

    READ TABLE gt_mara INTO ls_mara WITH KEY matnr = ls_final-matnr
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-matkl = ls_mara-matkl.
    ENDIF.

    CLEAR: lv_wmengj,lv_wmengm,lv_wmengk.

    LOOP AT  gt_vbfaj INTO ls_vbfaj WHERE vbelv = ls_final-vbeln
                                     AND posnv = ls_final-posnr.
*                                     AND vbtyp_n = 'J'.

      MOVE ls_vbfaj-rfmng_flo TO lv_meng.
      lv_wmengj = lv_wmengj + lv_meng.
      CLEAR lv_meng.

      ls_final-vbelv = ls_vbfaj-vbeln.

      READ TABLE gt_likp INTO ls_likp WITH KEY vbeln = ls_final-vbelv
                                     BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        ls_final-lfdat = ls_likp-lfdat.
      ENDIF.

      IF ls_vbak-auart = 'YBFC'.
        LOOP AT gt_vbfa5 INTO ls_vbfam WHERE vbelv = ls_vbfaj-vbeln
                                         AND posnv = ls_vbfaj-posnn.
          READ TABLE gt_vbrk_vbeln TRANSPORTING NO FIELDS
                                           WITH KEY vbeln = ls_vbfam-vbeln
                                                    fksto = space
                                                    BINARY SEARCH.

          CHECK sy-subrc IS INITIAL.


          MOVE ls_vbfam-rfmng_flo TO lv_meng.
          lv_wmengm = lv_wmengm + lv_meng.
          CLEAR lv_meng.

        ENDLOOP.
        IF sy-subrc IS NOT INITIAL.
          LOOP AT gt_vbfa5 INTO ls_vbfam WHERE vbelv = ls_vbap-vbeln
                                           AND posnv = ls_vbap-posnr.
            READ TABLE gt_vbrk_vbeln TRANSPORTING NO FIELDS
                                             WITH KEY vbeln = ls_vbfam-vbeln
                                                      fksto = space
                                                      BINARY SEARCH.

            CHECK sy-subrc IS INITIAL.


            MOVE ls_vbfam-rfmng_flo TO lv_meng.
            lv_wmengm = lv_wmengm + lv_meng.
            CLEAR lv_meng.
            lflg_so_sts_chk = abap_true.
          ENDLOOP.
        ENDIF.
      ELSE.
        LOOP AT gt_vbfam INTO ls_vbfam WHERE vbelv = ls_vbfaj-vbeln
                                         AND posnv = ls_vbfaj-posnn.

          READ TABLE gt_vbrk_vbeln TRANSPORTING NO FIELDS
                                   WITH KEY vbeln = ls_vbfam-vbeln
                                            fksto = space
                                            BINARY SEARCH.
          CHECK sy-subrc IS INITIAL.


          MOVE ls_vbfam-rfmng_flo TO lv_meng.
          lv_wmengm = lv_wmengm + lv_meng.
          CLEAR lv_meng.
        ENDLOOP.
      ENDIF.

      LOOP AT gt_vbfak INTO ls_vbfak WHERE vbelv = ls_vbfaj-vbeln
                                       AND posnv = ls_vbfaj-posnn.
        MOVE ls_vbfak-rfmng_flo TO lv_meng.
        lv_wmengk = lv_wmengk + lv_meng.
        CLEAR lv_meng.
      ENDLOOP.
      IF lflg_so_sts_chk IS NOT INITIAL.
        IF ls_vbup-gbsta = 'C' AND
         ( lv_lfgsa <> 'A' OR lv_lfgsa <> 'B' ).
          lflg_no_dlv = abap_true.
          CONTINUE.
        ENDIF.
      ELSE.
        READ TABLE gt_vbup INTO ls_vbupj WITH KEY vbeln = ls_vbfaj-vbeln
                                                  posnr = ls_vbfaj-posnn
                                                  BINARY SEARCH.
        IF ls_vbupj-gbsta = 'C' AND
         ( ls_vbupj-fksta <> 'A' OR ls_vbupj-fksta <> 'B' ).
          CONTINUE.
        ENDIF.
      ENDIF.

      IF ls_vbupj-wbsta = 'A'.
        ls_final-wbsta = 'Not yet processed'.
      ELSEIF ls_vbupj-wbsta = 'B'.
        ls_final-wbsta = 'Partially processed'.
      ELSEIF ls_vbupj-wbsta = 'C'.
        ls_final-wbsta = 'Completely processed'.
      ENDIF.

      ls_final-wmeng = ls_final-kwmeng - lv_wmengm.
      ls_final-rfwrt = ( ls_final-netwr / ls_final-kwmeng ) * ls_final-wmeng.
      lflg_no_dlv = abap_true.

*      CHECK ls_final-wmeng IS NOT INITIAL.
      APPEND ls_final TO gt_final.

    ENDLOOP.

    IF ls_vbup-gbsta = 'C' AND
     ( lv_lfgsa <> 'A' OR lv_lfgsa <> 'B' ).

      CONTINUE.
    ENDIF.

    IF lflg_no_dlv IS INITIAL.

      IF ls_vbupj-wbsta = 'A'.
        ls_final-wbsta = 'Not yet processed'.
      ELSEIF ls_vbupj-wbsta = 'B'.
        ls_final-wbsta = 'Partially processed'.
      ELSEIF ls_vbupj-wbsta = 'C'.
        ls_final-wbsta = 'Completely processed'.
      ENDIF.


      ls_final-wmeng = ls_final-kwmeng - lv_wmengm.
      ls_final-rfwrt = ( ls_final-netwr / ls_final-kwmeng ) * ls_final-wmeng.
*      CHECK ls_final-wmeng IS NOT INITIAL.
      APPEND ls_final TO gt_final.
    ENDIF.
  ENDLOOP.
ENDFORM.                    " MERGE_DATA
*&---------------------------------------------------------------------*
*&      Form  DISPLAY_ALV
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM display_alv .

  DATA: lr_table   TYPE REF TO cl_salv_table.
  DATA: lr_functions TYPE REF TO cl_salv_functions_list.
  DATA: lr_columns TYPE REF TO cl_salv_columns.


  IF s_mail IS NOT INITIAL AND sy-batch EQ abap_true.
    PERFORM create_xls_file.
    PERFORM send_mail.
  ENDIF.


  TRY.
      cl_salv_table=>factory(
        IMPORTING
          r_salv_table = lr_table
        CHANGING
          t_table      = gt_final ).
    CATCH cx_salv_msg.                                  "#EC NO_HANDLER
  ENDTRY.

  lr_functions = lr_table->get_functions( ).
  lr_functions->set_default( abap_true ).
  lr_functions->set_all( abap_true ).
  lr_columns = lr_table->get_columns( ).

  PERFORM set_field_names USING lr_columns.

  lr_table->display( ).

ENDFORM.                    " DISPLAY_ALV

*&---------------------------------------------------------------------*
*&      Form  set_field_names
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->IR_COLUMNS text
*----------------------------------------------------------------------*
FORM set_field_names  USING    ir_columns TYPE REF TO cl_salv_columns.
  DATA: lr_column TYPE REF TO cl_salv_column,
        lv_str_s  TYPE scrtext_s,
        lv_str_m  TYPE  scrtext_m,
        lv_str_l  TYPE scrtext_l.

  TRY.
      lr_column = ir_columns->get_column( 'RTIME' ).
      lv_str_s = 'Req. Time'.
      lv_str_m = 'Required Time'.
      lv_str_l = lv_str_m.
      lr_column->set_short_text( lv_str_s ).
      lr_column->set_medium_text( lv_str_m ).
      lr_column->set_long_text( lv_str_l ).
      lr_column->set_output_length( 20 ).
    CATCH cx_salv_not_found.                            "#EC NO_HANDLER
  ENDTRY.




**  ir_columns->set_column_position( EXPORTING
** columnname = 'SR_NO'
** position   = 1 ).

*       ir_columns->set_column_position( EXPORTING
*      columnname = 'SR_NO'
*      position   = 1 ).
*  TRY.
*      lr_column = ir_columns->get_column( 'SR_NO' ).
*      lv_str_s = 'Sr. No.'.
*      lr_column->set_short_text( lv_str_s ).
*      lr_column->set_output_length( 7 ).
*
*    CATCH cx_salv_not_found.                            "#EC NO_HANDLER
*  ENDTRY.
*  TRY.
*      lr_column = ir_columns->get_column( 'RTIME' ).
*      lv_str_s = 'Req. Time'.
*      lv_str_m = 'Required Time'.
*      lv_str_l = lv_str_m.
*      lr_column->set_short_text( lv_str_s ).
*      lr_column->set_medium_text( lv_str_m ).
*      lr_column->set_long_text( lv_str_l ).
*      lr_column->set_output_length( 20 ).
*    CATCH cx_salv_not_found.                            "#EC NO_HANDLER
*  ENDTRY.
*  TRY.
*      lr_column = ir_columns->get_column( 'VDATU' ).
*      lv_str_m = 'Del. Date'.
*      lv_str_l = lv_str_m.
*      lr_column->set_medium_text( lv_str_m ).
*      lr_column->set_long_text( lv_str_l ).
*      lr_column->set_output_length( 20 ).
*    CATCH cx_salv_not_found.                            "#EC NO_HANDLER
*  ENDTRY.
*  "
*  TRY.
*      lr_column = ir_columns->get_column( 'STRAS' ).
*      lv_str_m = 'Job Name/Site'.
*      lv_str_l = lv_str_m.
*      lr_column->set_medium_text( lv_str_m ).
*      lr_column->set_long_text( lv_str_l ).
*      lr_column->set_output_length( 40 ).
*    CATCH cx_salv_not_found.                          "#EC NO_HANDLER
*  ENDTRY.

ENDFORM.                    " SET_FIELD_NAMES


*&---------------------------------------------------------------------*
*&      Form  create_Xls_File
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM create_xls_file.
  DATA:
   xlsx_writer                   TYPE REF TO zscn_cl_xlsx_writer.

  CONSTANTS:
    color_column TYPE lvc_fname VALUE 'ALV_COLOR_COL'.

  CLEAR: gv_attachment_length,gt_xlsx_attachment,gt_pdf_attachment.

  gt_final_xls[] = gt_final[].

  CREATE OBJECT xlsx_writer
    EXPORTING
      sheet_content = gt_final_xls.

  xlsx_writer->add_custom_doc_property(
       property_name  = 'sapSourceSystemID'                 "#EC NOTEXT
       property_value = sy-sysid  ).

  xlsx_writer->add_custom_doc_property(
  property_name  = 'sapSourceClient'                        "#EC NOTEXT
  property_value = sy-mandt  ).

  xlsx_writer->insert_border(
         alias            = 'boxed'                         "#EC NOTEXT
         left_style       = 'thick'                         "#EC NOTEXT
         right_style      = 'thick'                         "#EC NOTEXT
         top_style        = 'thick'                         "#EC NOTEXT
         bottom_style     = 'thick'                         "#EC NOTEXT
          ).
  xlsx_writer->insert_font(
     alias     = 'myFont'                                   "#EC NOTEXT
     name      = 'Calibri'                                  "#EC NOTEXT
     size      = 11
     bold      = abap_true
     italic    = abap_true
     underline = abap_true ).

  xlsx_writer->build( ).

  xlsx_writer->get_file_as_email_attachment(
      IMPORTING
        xlsx_attachment   = gt_xlsx_attachment
        attachment_lenght = gv_attachment_length
    ).


ENDFORM.                    "create_xls_file

*&---------------------------------------------------------------------*
*&      Form  send_mail
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM send_mail.

  DATA:  lo_send_request TYPE REF TO cl_bcs VALUE IS INITIAL.
  CLASS cl_bcs DEFINITION LOAD.
  DATA: lo_document   TYPE REF TO cl_document_bcs VALUE IS INITIAL, "document object
        i_text        TYPE bcsy_text, "Table for body
        w_text        LIKE LINE OF i_text, "work area for message body
        lo_sender     TYPE REF TO if_sender_bcs VALUE IS INITIAL,
        lo_recipient  TYPE REF TO if_recipient_bcs VALUE IS INITIAL,
        lt_att_head   TYPE soli_tab,
        ls_imessage   TYPE solisti1,
        lt_attachment TYPE solix_tab,
        lv_atta_type  TYPE soodk-objtp,
        l_attsubject  TYPE sood-objdes,
        ls_mail       LIKE LINE OF s_mail,
        lt_imessage   TYPE STANDARD TABLE OF solisti1,
        lv_filename   TYPE string,
        lv_text_line  TYPE soli,
        lv_subject    TYPE so_obj_des,
        l_val         TYPE char10.



  lo_send_request = cl_bcs=>create_persistent( ).
* Message body and subject
  WRITE sy-datum TO l_val.

  CONCATENATE 'Your open orders with Bailey Metals on' l_val INTO lv_subject SEPARATED BY space.
*Set body

  ls_imessage-line = TEXT-001.
  APPEND ls_imessage TO lt_imessage.     " body_text is an internal table
  CONCATENATE TEXT-002 l_val  INTO ls_imessage-line SEPARATED BY space.
  CONCATENATE ls_imessage-line '.' INTO ls_imessage-line.
  APPEND ls_imessage TO lt_imessage.

  lo_document = cl_document_bcs=>create_document( "create document
  i_type = 'RAW' "Type of document HTM, TXT etc
  i_text =  lt_imessage "email body internal table
  i_subject = lv_subject ). "email subject here p_sub input parameter
* Pass the document to send request
  lo_send_request->set_document( lo_document ).

  CONCATENATE 'Open Orders.' 'xlsx' INTO lv_filename.
  lv_atta_type = 'XLS'.

  CONCATENATE '&SO_FILENAME=' lv_filename INTO lv_text_line.
  APPEND lv_text_line TO lt_att_head.

  WRITE 'Open Orders' TO l_attsubject.
*   Create Attachment
  TRY.
      lo_document->add_attachment( EXPORTING
                                      i_attachment_type = lv_atta_type
                                      i_attachment_subject = l_attsubject
                                      i_attachment_size = gv_attachment_length
                                      i_att_content_hex = gt_xlsx_attachment
                                      i_attachment_header = lt_att_head ).

  ENDTRY.

  TRY.
      lo_sender = cl_sapuser_bcs=>create( sy-uname ). "sender is the logged in user
* Set sender to send request
      lo_send_request->set_sender(
      EXPORTING
      i_sender = lo_sender ).
    CATCH cx_address_bcs.
****Catch exception here
  ENDTRY.

**Set recipient
  LOOP AT s_mail INTO ls_mail.
    lo_recipient = cl_cam_address_bcs=>create_internet_address( ls_mail-low ). "Here Recipient is email input p_email
    TRY.
        lo_send_request->add_recipient(
            EXPORTING
            i_recipient = lo_recipient
            i_express = 'X' ).
*      CATCH cx_send_req_bcs INTO bcs_exception .
**Catch exception here
    ENDTRY.

  ENDLOOP.
  TRY.
      CALL METHOD lo_send_request->set_send_immediately
        EXPORTING
          i_send_immediately = abap_true. "here selection screen input p_send
  ENDTRY.
  TRY.
** Send email
      lo_send_request->send(
      EXPORTING
      i_with_error_screen = 'X' ).

      COMMIT WORK.
      IF sy-subrc = 0. "mail sent successfully
        MESSAGE 'Mail sent successfully' TYPE 'S'.
      ENDIF.
  ENDTRY.
ENDFORM.                    "send_mail

*adding
FORM before_rfc
   USING
      p_before_rfc_imp     TYPE spta_t_before_rfc_imp
   CHANGING
      p_before_rfc_exp     TYPE spta_t_before_rfc_exp
      pt_rfcdata           TYPE spta_t_indxtab
      p_failed_objects     TYPE spta_t_failed_objects
      p_objects_in_process TYPE spta_t_objects_in_process
      p_user_param.

  TYPES: BEGIN OF t_rfcdata,
           BEGIN OF importing,
             it_vbap       LIKE gt_vbap,
             it_vbup       LIKE gt_vbup,
             it_vbak       LIKE gt_vbak,
             it_vbak       LIKE gt_vbak,
             it_kna1       LIKE gt_kna1,
             it_knvp       LIKE gt_knvp,
             it_makt       LIKE gt_makt,
             it_mara       LIKE gt_mara,
             it_vbfaj      LIKE gt_vbfaj,
             it_likp       LIKE gt_likp,
             it_vbfa5      LIKE gt_vbfa5,
             it_vbrk_vbeln LIKE gt_vbrk_vbeln,
             it_vbfa5      LIKE gt_vbfa5,
             it_vbfam      LIKE gt_vbfam,
             it_vbfak      LIKE gt_vbfak,
           END OF importing,
           BEGIN OF exporting,
             et_final TYPE TABLE OF zopen_ord_output,
           END OF exporting,
         END OF t_rfcdata.

  DATA:
    ld_package_size LIKE sy-tabix,
    lt_vbap         TYPE TABLE OF ty_vbap,
    lt_task_data    TYPE t_rfcdata.

  DATA: l_counter     TYPE i,
        l_no_of_items TYPE i VALUE 10000,
        lt_vbap       TYPE TABLE OF ty_vbap.


* Delete list of objects in process
  CLEAR ld_obj_in_process.
* Check if there are objects from previously failed tasks left ...


  LOOP AT gt_vbap INTO ls_vbap.
    IF ( l_counter < l_no_of_items AND ls_vbap IS NOT INITIAL ).
      APPEND ls_vbap TO lt_vbap.
      DELETE gt_vbap INDEX 1.
      l_counter = l_counter + 1.
    ELSE.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF lt_vbap IS NOT INITIAL.
    lt_task_data-importing-it_vbap = lt_vbap.
    lt_task_data-importing-it_vbak = gt_vbap.
    lt_task_data-importing-it_vbup = gt_vbup.
    lt_task_data-importing-it_kna1 = gt_kna1.
    lt_task_data-importing-it_knvp = gt_knvp.
    lt_task_data-importing-it_makt = gt_makt.
    lt_task_data-importing-it_mara = gt_mara.
    lt_task_data-importing-it_mara = gt_mara.
    lt_task_data-importing-it_mara = gt_mara.
    lt_task_data-importing-it_vbfaj = gt_vbfaj.
    lt_task_data-importing-it_vbfa5 = gt_vbfa5.
    lt_task_data-importing-it_vbfam = gt_vbfam.
    lt_task_data-importing-it_vbfak = gt_vbfak.
    lt_task_data-importing-it_vbrk_vbeln = gt_vbrk_vbeln.

  ENDIF.

  IF lt_vbap IS INITIAL.
    CLEAR p_before_rfc_exp-start_rfc.
    EXIT.
  ENDIF.

  p_before_rfc_exp-start_rfc = 'X'.


  CALL FUNCTION 'SPTA_INDX_PACKAGE_ENCODE'
    EXPORTING
      data    = lt_task_data
    IMPORTING
      indxtab = pt_rfcdata.

ENDFORM.                               "BEFORE_RFC


*---------------------------------------------------------------------*
*       FORM IN_RFC                                                   *
*---------------------------------------------------------------------*
*       Callback-Form invoked within the RFC                          *
*---------------------------------------------------------------------*
FORM in_rfc
   USING
      p_in_rfc_imp  TYPE spta_t_in_rfc_imp
   CHANGING
      p_in_rfc_exp  TYPE spta_t_in_rfc_exp
      p_rfcdata     TYPE spta_t_indxtab.

  DATA:
       ld_taskdata   TYPE t_rfcdata.

  DATA: lt_final      TYPE TABLE OF zopen_ord_output,
        lt_vbak       TYPE TABLE OF ty_vbak,
        lt_mara       TYPE TABLE OF ty_mara,
        lt_knvp       TYPE TABLE OF ty_knvp,
        lt_kna1       TYPE TABLE OF ty_kna1,
        lt_vbap       TYPE TABLE OF ty_vbap,
        lt_makt       TYPE TABLE OF makt,
        lt_vbfak      TYPE TABLE OF ty_vbfa,
        lt_vbfaj      TYPE TABLE OF ty_vbfa,
        lt_vbfa5      TYPE TABLE OF ty_vbfa,
        lt_vbfam      TYPE TABLE OF ty_vbfa,
        lt_vbfar      TYPE TABLE OF ty_vbfa,
        lt_likp       TYPE TABLE OF ty_likp,
        lt_vapma      TYPE TABLE OF ty_vapma,
        lt_vbrk_vbeln TYPE TABLE OF ty_vbrk,
        lt_vbup       TYPE TABLE OF ty_vbup.

  DATA: ls_final        TYPE zopen_ord_output,
        ls_vbak         TYPE ty_vbak,
        ls_makt         TYPE makt,
        ls_kna1         TYPE ty_kna1,
        lv_jmeng        TYPE rfmng,
        lv_meng         TYPE rfmng,
        lv_kmeng        TYPE rfmng,
        lv_wmengj       TYPE rfmng,
        lv_wmengk       TYPE rfmng,
        lv_wmengm       TYPE rfmng,
        ls_mara         TYPE ty_mara,
        lflg_no_dlv     TYPE abap_bool,
        ls_vbfak        TYPE ty_vbfa,
        ls_vbfam        TYPE ty_vbfa,
        ls_vbfaj        TYPE ty_vbfa,
        ls_likp         TYPE ty_likp,
        ls_vbup         TYPE ty_vbup,
        ls_vbupj        TYPE ty_vbup,
        ls_knvp         TYPE ty_knvp,
        lv_lfgsa        TYPE char1,
        lflg_so_sts_chk TYPE char1,
        ls_vbap         TYPE ty_vbap.


* Unpack RFC input data (that has been packed in the BEFORE_RFC form)
  CALL FUNCTION 'SPTA_INDX_PACKAGE_DECODE'
    EXPORTING
      indxtab = p_rfcdata
    IMPORTING
      data    = lt_taskdata.


* Fill result tables
* This would include data for result lists, message handler etc.



  lt_vbap          =       lt_task_data-importing-it_vbap .
  lt_vbap          =       lt_task_data-importing-it_vbak .
  lt_vbup          =       lt_task_data-importing-it_vbup .
  lt_kna1          =       lt_task_data-importing-it_kna1 .
  lt_knvp          =       lt_task_data-importing-it_knvp .
  lt_makt          =       lt_task_data-importing-it_makt .
  lt_mara          =       lt_task_data-importing-it_mara .
  lt_vbfaj         =       lt_task_data-importing-it_vbfaj.
  lt_vbfa5         =       lt_task_data-importing-it_vbfa5.
  lt_vbfam         =       lt_task_data-importing-it_vbfam.
  lt_vbfak         =       lt_task_data-importing-it_vbfak.
  lt_vbrk_vbeln    =       lt_task_data-importing-it_vbrk_vbeln.


  SORT lt_vbak BY vbeln.
  SORT lt_knvp BY kunnr parvw.
  DELETE ADJACENT DUPLICATES FROM lt_knvp COMPARING ALL FIELDS.
  SORT lt_kna1 BY kunnr.
  DELETE ADJACENT DUPLICATES FROM lt_kna1 COMPARING ALL FIELDS.
  SORT lt_makt BY matnr.
  SORT lt_mara BY matnr.
  SORT lt_vbfaj BY vbelv posnv vbtyp_n.
  SORT lt_vbfak BY vbelv posnv vbtyp_n.
  SORT lt_vbfam BY vbelv posnv vbtyp_n.
  SORT lt_likp BY vbeln.
  SORT lt_vbrk_vbeln BY vbeln fksto.
  SORT lt_vbup BY vbeln posnr.
  SORT lt_vbap BY vbeln posnr.

  LOOP AT lt_vbap INTO ls_vbap.

    CLEAR: ls_vbak, ls_makt, ls_mara, ls_vbfaj, ls_likp, ls_vbup,
           ls_knvp, ls_kna1, lv_wmengk, ls_vbfak, ls_vbfam, lv_lfgsa,
           ls_final, lv_wmengm, lv_wmengj,lflg_no_dlv,ls_vbupj,lflg_so_sts_chk.

    MOVE-CORRESPONDING ls_vbap TO ls_final.

    READ TABLE lt_vbup INTO ls_vbup WITH KEY vbeln = ls_final-vbeln
                                             posnr = ls_final-posnr
                                             BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      MOVE-CORRESPONDING ls_vbup TO ls_final.
      lv_lfgsa = ls_vbup-lfgsa.
    ENDIF.

    IF ls_vbup-lfgsa = 'A'.
      ls_final-lfgsa = 'Not yet delivered'.
    ELSEIF ls_vbup-lfgsa = 'B'.
      ls_final-lfgsa = 'Partially delivered'.
    ELSEIF ls_vbup-lfgsa = 'C'.
      ls_final-lfgsa = 'Completely delivered'.
    ENDIF.

    READ TABLE lt_vbak INTO ls_vbak WITH KEY vbeln = ls_vbap-vbeln
                                    BINARY SEARCH.
    IF sy-subrc IS NOT INITIAL.
      CONTINUE.
    ENDIF.
    MOVE-CORRESPONDING ls_vbak TO ls_final.
*    READ TABLE gt_knvp INTO ls_knvp WITH KEY kunnr = ls_vbak-kunnr
*                                             parvw = 'AG'
*                                    BINARY SEARCH.
*    IF sy-subrc IS INITIAL.
*      ls_final-slifn = ls_knvp-lifnr.
*    ENDIF.

    READ TABLE lt_kna1 INTO ls_kna1 WITH KEY kunnr = ls_vbak-kunnr BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-name = ls_kna1-name1.
    ENDIF.

    READ TABLE lt_knvp INTO ls_knvp WITH KEY kunnr = ls_vbak-kunnr
                                             parvw = 'RG'
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-kunn2 = ls_knvp-kunn2.
      READ TABLE lt_kna1 INTO ls_kna1 WITH KEY kunnr = ls_knvp-kunn2 BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        ls_final-name1 = ls_kna1-name1.
      ENDIF.
    ENDIF.

    READ TABLE lt_makt INTO ls_makt WITH KEY matnr = ls_final-matnr
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-maktx = ls_makt-maktx.
    ENDIF.

    READ TABLE lt_mara INTO ls_mara WITH KEY matnr = ls_final-matnr
                                    BINARY SEARCH.
    IF sy-subrc IS INITIAL.
      ls_final-matkl = ls_mara-matkl.
    ENDIF.

    CLEAR: lv_wmengj,lv_wmengm,lv_wmengk.

    LOOP AT  lt_vbfaj INTO ls_vbfaj WHERE vbelv = ls_final-vbeln
                                     AND posnv = ls_final-posnr.
*                                     AND vbtyp_n = 'J'.

      MOVE ls_vbfaj-rfmng_flo TO lv_meng.
      lv_wmengj = lv_wmengj + lv_meng.
      CLEAR lv_meng.

      ls_final-vbelv = ls_vbfaj-vbeln.

      READ TABLE lt_likp INTO ls_likp WITH KEY vbeln = ls_final-vbelv
                                     BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        ls_final-lfdat = ls_likp-lfdat.
      ENDIF.

      IF ls_vbak-auart = 'YBFC'.
        LOOP AT lt_vbfa5 INTO ls_vbfam WHERE vbelv = ls_vbfaj-vbeln
                                         AND posnv = ls_vbfaj-posnn.
          READ TABLE lt_vbrk_vbeln TRANSPORTING NO FIELDS
                                           WITH KEY vbeln = ls_vbfam-vbeln
                                                    fksto = space
                                                    BINARY SEARCH.

          CHECK sy-subrc IS INITIAL.


          MOVE ls_vbfam-rfmng_flo TO lv_meng.
          lv_wmengm = lv_wmengm + lv_meng.
          CLEAR lv_meng.

        ENDLOOP.
        IF sy-subrc IS NOT INITIAL.
          LOOP AT lt_vbfa5 INTO ls_vbfam WHERE vbelv = ls_vbap-vbeln
                                           AND posnv = ls_vbap-posnr.
            READ TABLE lt_vbrk_vbeln TRANSPORTING NO FIELDS
                                             WITH KEY vbeln = ls_vbfam-vbeln
                                                      fksto = space
                                                      BINARY SEARCH.

            CHECK sy-subrc IS INITIAL.


            MOVE ls_vbfam-rfmng_flo TO lv_meng.
            lv_wmengm = lv_wmengm + lv_meng.
            CLEAR lv_meng.
            lflg_so_sts_chk = abap_true.
          ENDLOOP.
        ENDIF.
      ELSE.
        LOOP AT lt_vbfam INTO ls_vbfam WHERE vbelv = ls_vbfaj-vbeln
                                         AND posnv = ls_vbfaj-posnn.

          READ TABLE lt_vbrk_vbeln TRANSPORTING NO FIELDS
                                   WITH KEY vbeln = ls_vbfam-vbeln
                                            fksto = space
                                            BINARY SEARCH.
          CHECK sy-subrc IS INITIAL.


          MOVE ls_vbfam-rfmng_flo TO lv_meng.
          lv_wmengm = lv_wmengm + lv_meng.
          CLEAR lv_meng.
        ENDLOOP.
      ENDIF.

      LOOP AT lt_vbfak INTO ls_vbfak WHERE vbelv = ls_vbfaj-vbeln
                                       AND posnv = ls_vbfaj-posnn.
        MOVE ls_vbfak-rfmng_flo TO lv_meng.
        lv_wmengk = lv_wmengk + lv_meng.
        CLEAR lv_meng.
      ENDLOOP.
      IF lflg_so_sts_chk IS NOT INITIAL.
        IF ls_vbup-gbsta = 'C' AND
         ( lv_lfgsa <> 'A' OR lv_lfgsa <> 'B' ).
          lflg_no_dlv = abap_true.
          CONTINUE.
        ENDIF.
      ELSE.
        READ TABLE lt_vbup INTO ls_vbupj WITH KEY vbeln = ls_vbfaj-vbeln
                                                  posnr = ls_vbfaj-posnn
                                                  BINARY SEARCH.
        IF ls_vbupj-gbsta = 'C' AND
         ( ls_vbupj-fksta <> 'A' OR ls_vbupj-fksta <> 'B' ).
          CONTINUE.
        ENDIF.
      ENDIF.

      IF ls_vbupj-wbsta = 'A'.
        ls_final-wbsta = 'Not yet processed'.
      ELSEIF ls_vbupj-wbsta = 'B'.
        ls_final-wbsta = 'Partially processed'.
      ELSEIF ls_vbupj-wbsta = 'C'.
        ls_final-wbsta = 'Completely processed'.
      ENDIF.

      ls_final-wmeng = ls_final-kwmeng - lv_wmengm.
      ls_final-rfwrt = ( ls_final-netwr / ls_final-kwmeng ) * ls_final-wmeng.
      lflg_no_dlv = abap_true.

*      CHECK ls_final-wmeng IS NOT INITIAL.
      APPEND ls_final TO lt_final.

    ENDLOOP.

    IF ls_vbup-gbsta = 'C' AND
     ( lv_lfgsa <> 'A' OR lv_lfgsa <> 'B' ).

      CONTINUE.
    ENDIF.

    IF lflg_no_dlv IS INITIAL.

      IF ls_vbupj-wbsta = 'A'.
        ls_final-wbsta = 'Not yet processed'.
      ELSEIF ls_vbupj-wbsta = 'B'.
        ls_final-wbsta = 'Partially processed'.
      ELSEIF ls_vbupj-wbsta = 'C'.
        ls_final-wbsta = 'Completely processed'.
      ENDIF.


      ls_final-wmeng = ls_final-kwmeng - lv_wmengm.
      ls_final-rfwrt = ( ls_final-netwr / ls_final-kwmeng ) * ls_final-wmeng.
*      CHECK ls_final-wmeng IS NOT INITIAL.
      APPEND ls_final TO lt_final.
    ENDIF.
  ENDLOOP.

  lt_task_data-exporting-et_final = lt_final.


* * Repack output data for AFTER_RFC form
  CALL FUNCTION 'SPTA_INDX_PACKAGE_ENCODE'
    EXPORTING
      data    = lt_taskdata
    IMPORTING
      indxtab = p_rfcdata.

ENDFORM.


*---------------------------------------------------------------------*
*       FORM AFTER_RFC                                                *
*---------------------------------------------------------------------*
*       Callback-Form invoked after RFC                               *
*---------------------------------------------------------------------*
FORM after_rfc
   USING
      p_rfcdata            TYPE spta_t_indxtab
      p_rfcsubrc           TYPE sy-subrc
      p_rfcmsg             TYPE spta_t_rfcmsg
      p_objects_in_process TYPE spta_t_objects_in_process
      p_after_rfc_imp      TYPE spta_t_after_rfc_imp
   CHANGING
      p_after_rfc_exp      TYPE spta_t_after_rfc_exp
      p_user_param.

  DATA:
    ld_obj_in_process LIKE LINE OF p_objects_in_process,
    ld_tabsize        TYPE sy-tabix,
    ld_taskdata       TYPE t_rfcdata.


  IF p_rfcsubrc IS INITIAL.
* No RFC error occured

* Unpack RFC output data and add RFC-results to global data,
* e.g. output list, message handler etc.
    CALL FUNCTION 'SPTA_INDX_PACKAGE_DECODE'
      EXPORTING
        indxtab = p_rfcdata
      IMPORTING
        data    = ld_taskdata.
    APPEND LINES OF ld_taskdata-exporting-workarea
           TO gt_final.
    EXIT.
  ENDIF.

ENDFORM.
*&---------------------------------------------------------------------*
*&      Form  SPTA_PARA_PROCESSING
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM spta_para_processing .


  CALL FUNCTION 'SPTA_PARA_PROCESS_START_2'
    EXPORTING
      server_group             = rfcgroup
      max_no_of_tasks          = 10
      before_rfc_callback_form = 'BEFORE_RFC'
      in_rfc_callback_form     = 'IN_RFC'
      after_rfc_callback_form  = 'AFTER_RFC'
      callback_prog            = sy-repid
    EXCEPTIONS
      invalid_server_group     = 1
      no_resources_available   = 2
      OTHERS                   = 3.


ENDFORM.
